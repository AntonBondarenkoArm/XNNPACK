// Copyright 2025 Microchip
//
// This source code is licensed under the BSD-style license found in the
// LICENSE file in the root directory of this source tree.

$assert LMUL in [1, 2]

#include <assert.h>
#include <riscv_vector.h>
#include "src/xnnpack/common.h"
#include "src/xnnpack/reduce.h"

void xnn_qs8_rdsum_ukernel_${ACCUMULATORS}p${ACCUMULATORS}x__rvv_u${LMUL}v(
    size_t rows,
    size_t channels,
    const int8_t* input,
    size_t input_stride,
    const int8_t* zero,
    int32_t* output,
    const struct xnn_qs8_rsum_params params[restrict XNN_MIN_ELEMENTS(1)])
{
  assert(rows != 0);
  assert(channels != 0);
  assert(input != NULL);
  assert(output != NULL);

  size_t input_increment = ${ACCUMULATORS} * input_stride;

  do {
    size_t vl = __riscv_vsetvl_e8m${LMUL}(channels); channels -= vl;

    const int8_t* i0 = input;
    $for ACC in range(1, ACCUMULATORS):
      const int8_t* i${ACC} = (const int8_t*) ((uintptr_t) i${ACC - 1} + input_stride);

    vint32m${LMUL*4}_t vacc = __riscv_vmv_v_x_i32m${LMUL*4}(0, vl);

    for (int r = rows; r > 0; r -= ${ACCUMULATORS}) {
      $for ACC in range(1, ACCUMULATORS, 2):
        if XNN_UNPREDICTABLE(r < ${ACC+1}) {
          i${ACC} = zero;
        }
        if XNN_UNPREDICTABLE(r <= ${ACC+1}) {
          i${ACC+1} = zero;
        }

      vint8m${LMUL}_t vinput;
      vint16m${LMUL*2}_t vinput16;
      $for ACC in range(ACCUMULATORS):
        vinput = __riscv_vle8_v_i8m${LMUL}(i${ACC}, vl);
        vinput16 = __riscv_vsext_vf2_i16m${LMUL*2}(vinput, vl);  
        vacc = __riscv_vwadd_wv_i32m${LMUL*4}(vacc, vinput16, vl);
        i${ACC} = (const int8_t*) ((uintptr_t) i${ACC} + input_increment);
    }

    vint32m${LMUL*4}_t voutput = __riscv_vle32_v_i32m${LMUL*4}(output, vl);
    voutput = __riscv_vadd_vv_i32m${LMUL*4}(voutput, vacc, vl);
    __riscv_vse32_v_i32m${LMUL*4}(output, voutput, vl); output += vl;

    input = (const int8_t*) ((uintptr_t) input + vl);

  } while (channels != 0);
}